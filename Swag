import pandas as pd
import numpy as np

# Function to compute distance between two sets of latitudes and longitudes
def haversine(lon1, lat1, lon2, lat2):
    R = 6371.0  # Radius of the earth in kilometers
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
    distance = R * c
    return distance

# Assuming 'fa_full_info_df' and 'leads_with_geo_good_df' dataframes are defined

# Original breakdown with the last bin reserved for unranked FAs
original_breakdown = [50, 30, 20]  # Example breakdown
unranked_allocation = 10  # Percentage of leads to allocate to unranked FAs
adjusted_breakdown = [x * (100 - unranked_allocation) / 100 for x in original_breakdown] + [unranked_allocation]

# Mark FAs as ranked or unranked
fa_full_info_df['Ranked'] = fa_full_info_df['Rank'].notna()

# Assign ranked FAs to bins based on the adjusted breakdown
ranked_fas = fa_full_info_df[fa_full_info_df['Ranked']].copy()
cumulative_breakdown = np.cumsum(adjusted_breakdown[:-1])  # Exclude unranked allocation for now
bin_limits = len(ranked_fas) * np.array(cumulative_breakdown) / 100
ranked_fas['Bin'] = np.digitize(range(len(ranked_fas)), bin_limits, right=False) + 1

# Assign unranked FAs to the last bin
unranked_fas = fa_full_info_df[~fa_full_info_df['Ranked']].copy()
unranked_fas['Bin'] = len(adjusted_breakdown)  # Last bin for unranked FAs

# Combine ranked and unranked FAs
fa_full_info_df = pd.concat([ranked_fas, unranked_fas])

# Calculate the number of leads to distribute to each bin
total_leads = len(leads_with_geo_good_df)
max_leads_per_bin = {i+1: total_leads * pct / 100 for i, pct in enumerate(adjusted_breakdown)}

# Pre-Process Leads (assuming 'leads_with_geo_good_df' is already defined)

# Initialize the count of leads assigned per bin
leads_assigned_per_bin = {i: 0 for i in range(1, len(adjusted_breakdown)+1)}

# Lead assignment loop
for index, lead_row in leads_with_geo_good_df.iterrows():
    for bin_num in range(1, len(adjusted_breakdown)+1):
        if leads_assigned_per_bin[bin_num] < max_leads_per_bin[bin_num]:
            potential_FAs = fa_full_info_df[(fa_full_info_df["Bin"] == bin_num)]
            # Further filtering of potential_FAs based on AUM and other criteria can be added here
            
            if not potential_FAs.empty:
                potential_FAs['distance'] = potential_FAs.apply(
                    lambda fa_row: haversine(lead_row['Longitude'], lead_row['Latitude'], fa_row['Longitude'], fa_row['Latitude']), axis=1)
                closest_FA = potential_FAs.loc[potential_FAs['distance'].idxmin()]
                
                # Assign the lead to the closest FA (further implementation needed for actual assignment)
                
                leads_assigned_per_bin
